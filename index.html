<!DOCTYPE HTML>
<html>
  <head>
    <title>Food Recipes | Exhibit Facet Search</title>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <link rel="stylesheet" href="https://www.simile-widgets.org/styles/common.css" type="text/css" />
    <link rel="stylesheet" href="food-exhibit.css" type="text/css" />
    <link href="food-exhibit-data-500recipes.json" type="application/json" rel="exhibit/data" />
    <script src="https://api.simile-widgets.org/exhibit/current/exhibit-api.js"></script>
    <style>
      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 10000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
      }
      .modal-content {
        background-color: white;
        margin: 3% auto;
        padding: 25px;
        border-radius: 6px;
        width: 80%;
        max-width: 900px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #eee;
      }
      .modal-title {
        font-size: 20px;
        font-weight: bold;
        color: #333;
      }
      .close-btn {
        font-size: 28px;
        font-weight: bold;
        color: #aaa;
        cursor: pointer;
        line-height: 20px;
      }
      .close-btn:hover {
        color: #000;
      }
      .review-item {
        margin: 15px 0;
        padding: 15px;
        background: #f9f9f9;
        border-left: 3px solid #4a90e2;
        border-radius: 3px;
        transition: all 0.2s;
      }
      .review-item:hover {
        background: #f0f0f0;
      }
      .review-text {
        line-height: 1.6;
        color: #333;
      }
      .highlight {
        padding: 2px 4px;
        border-radius: 2px;
        font-weight: 500;
      }
      .hl-audienceenjoyment { background-color: #ffeb3b; }
      .hl-tasteflavor { background-color: #a5d6a7; }
      .hl-texturemouthfeel { background-color: #90caf9; }
      .hl-mealtype { background-color: #ce93d8; }
      .hl-occasionholiday { background-color: #ffab91; }
      .hl-cuisinetype { background-color: #f48fb1; }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        margin: 15px 0;
        padding: 10px;
        background: #f5f5f5;
        border-radius: 3px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        font-size: 12px;
      }
      .legend-color {
        width: 20px;
        height: 12px;
        margin-right: 5px;
        border-radius: 2px;
      }
      .view-reviews-btn {
        display: inline-block;
        margin-top: 10px;
        padding: 8px 16px;
        background: #4a90e2;
        color: white;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        border: none;
      }
      .view-reviews-btn:hover {
        background: #357abd;
      }
      /* Custom search box styling */
      .search-container {
        margin-bottom: 15px;
      }
      .search-wrapper {
        display: flex;
        gap: 5px;
        margin-top: 5px;
      }
      .search-input {
        flex: 1;
        padding: 8px 12px;
        border: 2px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        outline: none;
      }
      .search-input:focus {
        border-color: #4a90e2;
      }
      .search-button {
        padding: 8px 16px;
        background: #4a90e2;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
      }
      .search-button:hover {
        background: #357abd;
      }
      .clear-button {
        padding: 8px 12px;
        background: #e0e0e0;
        color: #333;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      .clear-button:hover {
        background: #d0d0d0;
      }
      .search-hint {
        font-size: 11px;
        color: #666;
        margin-top: 4px;
        font-style: italic;
      }
      .search-status {
        margin-top: 8px;
        padding: 8px 12px;
        background: #e3f2fd;
        border-left: 3px solid #2196f3;
        border-radius: 3px;
        font-size: 13px;
        display: none;
      }
      .search-status.active {
        display: block;
      }
      .search-status-label {
        font-weight: 600;
        color: #1976d2;
      }
      .search-status-terms {
        color: #333;
        font-family: monospace;
        background: white;
        padding: 2px 6px;
        border-radius: 2px;
        margin-left: 4px;
      }
      /* Hide default Exhibit search box */
      .exhibit-facet-header-filterControl {
        display: none !important;
      }
      /* Recipe Modal */
      .recipe-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.6);
        z-index: 10000;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }
      .recipe-modal-content {
        position: relative;
        background: white;
        max-width: 1000px;
        margin: 0 auto;
        border-radius: 4px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      }
      .recipe-modal-close {
        position: absolute;
        top: 16px;
        right: 16px;
        width: 36px;
        height: 36px;
        background: white;
        border: 2px solid #ddd;
        border-radius: 50%;
        font-size: 24px;
        line-height: 32px;
        cursor: pointer;
        z-index: 10;
        color: #666;
        transition: all 0.2s;
      }
      .recipe-modal-close:hover {
        background: #f5f5f5;
        border-color: #999;
        color: #333;
      }
      .recipe-card {
        background: white;
        max-width: 100%;
        overflow: hidden;
      }
      /* Clickable thumbnails */
      .recipe-thumb {
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
      }
      .recipe-thumb:hover {
        transform: translateY(-4px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      }
      .recipe-thumb-caption {
        cursor: pointer;
        transition: color 0.2s;
      }
      .recipe-thumb:hover .recipe-thumb-caption {
        color: #333;
        font-weight: 500;
      }
      .recipe-header {
        display: flex;
        gap: 16px;
        padding: 20px;
        padding-top: 60px;
        border-bottom: 1px solid #e0e0e0;
        align-items: center;
      }
      .recipe-image-wrapper {
        flex-shrink: 0;
        width: 140px;
        height: 140px;
        border: 1px solid #e0e0e0;
        overflow: hidden;
      }
      .recipe-image-wrapper img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
      }
      .recipe-header-info {
        flex: 1;
        min-width: 0;
      }
      .recipe-title {
        margin: 0 0 8px 0;
        font-size: 20px;
        font-weight: 600;
        color: #222;
        line-height: 1.3;
      }
      .recipe-meta {
        display: flex;
        gap: 12px;
        font-size: 13px;
        color: #666;
      }
      .recipe-meta-item {
        padding: 0;
      }
      .recipe-content {
        padding: 16px;
        max-width: 100%;
        box-sizing: border-box;
      }
      .recipe-columns {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 12px;
        max-width: 100%;
      }
      @media (max-width: 900px) {
        .recipe-columns {
          grid-template-columns: 1fr;
        }
        .recipe-header {
          flex-direction: column;
          align-items: flex-start;
        }
        .recipe-image-wrapper {
          width: 100%;
          height: 180px;
        }
      }
      .recipe-column {
        min-width: 0;
      }
      .recipe-section {
        background: #fafafa;
        border: 1px solid #e0e0e0;
        padding: 14px;
        box-sizing: border-box;
      }
      /* Hide empty sections */
      .recipe-section:empty {
        display: none;
      }
      .recipe-section h4 {
        margin: 0 0 10px 0;
        color: #222;
        font-size: 14px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3px;
      }
      .ingredients-list,
      .instructions-list {
        margin: 0;
        padding-left: 18px;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .ingredients-list li,
      .instructions-list li {
        margin: 4px 0;
        line-height: 1.4;
        color: #444;
        font-size: 13px;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }
      .recipe-footer {
        border-top: 1px solid #e0e0e0;
        padding-top: 12px;
      }
      .recipe-tags {
        margin-bottom: 12px;
        padding: 10px;
        background: #f5f5f5;
        border: 1px solid #e0e0e0;
        font-size: 13px;
        color: #555;
      }
      .view-reviews-btn {
        width: 100%;
        padding: 10px;
        background: #333;
        color: white;
        border: none;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .view-reviews-btn:hover {
        background: #555;
      }
    </style>
  </head>
  <body>
    <table id="header">
      <tr style="vertical-align: middle;">
        <td>
          <h1>Food Recipe Facet Search (500 Recipes)</h1>
          <p>Browse 500 top recipes with LLM-extracted subjective features from 10,000 reviews.</p>
        </td>
      </tr>
    </table>

    <div id="body">
      <table id="exhibit" style="width: 100%; border-spacing: 10px; border: 0;">
        <tr>
          <td class="facet-column">
            <div class="search-container">
              <b>Search Attributes</b>
              <div class="search-wrapper">
                <input type="text"
                       id="customSearchBox"
                       class="search-input"
                       placeholder="e.g., Christmas food for my father" />
                <button class="search-button" onclick="performSmartSearch()">Search</button>
                <button class="clear-button" onclick="clearSearch()">Clear</button>
              </div>
              <div class="search-hint">Try: "spicy Asian dinner" or "Thanksgiving dessert" (Press Enter to search)</div>
              <div id="searchStatus" class="search-status">
                <span class="search-status-label">Searching for:</span>
                <span id="searchTermsDisplay" class="search-status-terms"></span>
              </div>
            </div>
            <!-- Removed TextSearch facet - implementing custom search instead -->
            <hr />
            <div data-ex-role="facet" data-ex-expression=".audience_attributes" data-ex-facet-label="Audience" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".occasion_attributes" data-ex-facet-label="Occasion" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".texture_attributes" data-ex-facet-label="Texture" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".taste_attributes" data-ex-facet-label="Taste & Flavor" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
          </td>
          <td class="view-column">
            <div data-ex-role="viewPanel">
              <!-- Recipe Detail Modal -->
              <div id="recipeModal" class="recipe-modal" style="display: none;">
                <div class="recipe-modal-content">
                  <button class="recipe-modal-close" onclick="closeRecipeModal()">&times;</button>
                  <div id="recipeModalBody"></div>
                </div>
              </div>

              <div data-ex-role="view"
                   data-ex-view-class="Thumbnail"
                   data-ex-show-all="true"
                   data-ex-paginate="true"
                   data-ex-possible-orders=".aggregated_rating, .review_count, .calories, .label">
                <table data-ex-role="lens" class="recipe-thumb" style="display: none;">
                  <tr>
                    <td class="recipe-thumb-image">
                      <div class="recipe-thumb-wrapper">
                        <img data-ex-src-content=".thumbnail" alt="recipe thumbnail" />
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td class="recipe-thumb-caption"><span data-ex-content="value"></span></td>
                  </tr>
                  <!-- Hidden data for modal -->
                  <tr style="display: none;">
                    <td>
                      <span class="recipe-data" data-ex-content=".id" data-field="id"></span>
                      <span class="recipe-data" data-ex-content=".label" data-field="name"></span>
                      <span class="recipe-data" data-ex-content=".image" data-field="image"></span>
                      <span class="recipe-data" data-ex-content=".aggregated_rating" data-field="rating"></span>
                      <span class="recipe-data" data-ex-content=".review_count" data-field="reviews"></span>
                      <span class="recipe-data" data-ex-content=".calories" data-field="calories"></span>
                      <span class="recipe-data" data-ex-content=".ingredients" data-field="ingredients"></span>
                      <span class="recipe-data" data-ex-content=".instructions" data-field="instructions"></span>
                      <span class="recipe-data" data-ex-content=".subjective_attributes" data-field="attributes"></span>
                    </td>
                  </tr>
                </table>
              </div>
            </div>
          </td>
          <td class="facet-column">
            <div data-ex-role="facet" data-ex-expression=".meal_type_attributes" data-ex-facet-label="Meal Type" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-expression=".type_attributes" data-ex-facet-label="Cuisine" data-ex-height="14em" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div data-ex-role="facet" data-ex-facet-class="NumericRange" data-ex-expression=".calories" data-ex-facet-label="Calories" data-ex-height="10em" data-ex-interval="100" data-ex-sort-mode="count" data-ex-sort-direction="forward"></div>
            <div style="text-align: center" data-ex-role="logo"></div>
          </td>
        </tr>
      </table>
    </div>

    <!-- Review Modal -->
    <div id="reviewModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <div class="modal-title" id="modalTitle">Recipe Reviews</div>
          <span class="close-btn" onclick="closeModal()">&times;</span>
        </div>
        <div class="legend">
          <div class="legend-item"><div class="legend-color hl-audienceenjoyment"></div> Audience</div>
          <div class="legend-item"><div class="legend-color hl-tasteflavor"></div> Taste & Flavor</div>
          <div class="legend-item"><div class="legend-color hl-texturemouthfeel"></div> Texture</div>
          <div class="legend-item"><div class="legend-color hl-mealtype"></div> Meal Type</div>
          <div class="legend-item"><div class="legend-color hl-occasionholiday"></div> Occasion</div>
          <div class="legend-item"><div class="legend-color hl-cuisinetype"></div> Cuisine</div>
        </div>
        <div id="modalReviews"></div>
      </div>
    </div>

    <script>
      let reviewData = null;
      let exhibitData = null;

      // Load exhibit data
      function loadExhibitData() {
        if (exhibitData) return Promise.resolve(exhibitData);

        return fetch('food-exhibit-data-500recipes.json')
          .then(response => response.json())
          .then(data => {
            exhibitData = data;
            return data;
          })
          .catch(err => {
            console.error('Error loading exhibit data:', err);
            return null;
          });
      }

      // Reviews are embedded in exhibit data - no separate load needed
      function getReviewsFromExhibit(recipeId) {
        if (!exhibitData) return [];

        const recipe = exhibitData.items.find(item => item.id == recipeId);
        return recipe ? recipe.reviews || [] : [];
      }

      // Get currently selected facet values by examining DOM
      function getSelectedFacets() {
        const allSelected = [];

        console.log('=== Searching for selected facets ===');

        // Look for all facet divs
        const facetDivs = document.querySelectorAll('[data-ex-role="facet"]');
        console.log('Found facet divs:', facetDivs.length);

        facetDivs.forEach(facetDiv => {
          const expression = facetDiv.getAttribute('data-ex-expression');
          if (!expression || expression.includes('NumericRange') || facetDiv.querySelector('[data-ex-facet-class="TextSearch"]')) {
            return; // Skip numeric and search facets
          }

          console.log('Examining facet:', expression);

          // Look for all divs within this facet that might be facet values
          // Exhibit uses specific class names for facet values
          const facetValues = facetDiv.querySelectorAll('div[class*="facet"], div[class*="value"]');
          console.log('  Found potential value elements:', facetValues.length);

          // Also try more generic approach - find all divs with text content
          const allDivs = facetDiv.querySelectorAll('div');
          let foundInThisFacet = 0;

          allDivs.forEach(div => {
            // Check if this div looks like a selected facet value
            const classes = div.className || '';
            const text = div.textContent?.trim() || '';
            const computedStyle = window.getComputedStyle(div);

            // Look for indicators of selection (broader check)
            const isSelected = classes.includes('selected') ||
                             classes.includes('checked') ||
                             classes.includes('exhibit-facet-value-selected') ||
                             div.style.fontWeight === 'bold' ||
                             div.style.fontWeight === '700' ||
                             computedStyle.fontWeight === 'bold' ||
                             computedStyle.fontWeight === '700' ||
                             parseInt(computedStyle.fontWeight) >= 700;

            if (isSelected && text && text.length > 0 && text.length < 200) {
              // Remove count like "(123)" and also leading numbers like "474 husband"
              let facetValue = text.split('(')[0].trim();

              // Remove leading number and space (e.g., "474 husband" -> "husband")
              facetValue = facetValue.replace(/^\d+\s+/, '');

              if (facetValue && !allSelected.includes(facetValue)) {
                console.log('  -> Found selected:', facetValue, 'in', expression, '(from:', text.substring(0, 50), ')');
                allSelected.push(facetValue);
                foundInThisFacet++;
              }
            }
          });

          console.log('  Found', foundInThisFacet, 'selected values in this facet');
        });

        console.log('Final selected facets:', allSelected);

        return {
          byDimension: {},
          all: allSelected
        };
      }

      // Show reviews for the currently displayed recipe
      function showReviewsForCurrentRecipe(button) {
        // Find the recipe detail div that contains this button
        const detailDiv = button.closest('.recipe-detail');

        // Get recipe name from the h2
        const recipeName = detailDiv.querySelector('h2 span').textContent;

        // Get selected facets
        const selectedFacets = getSelectedFacets();

        // Load exhibit data to find recipe ID by name
        loadExhibitData().then(exhibitData => {
          if (!exhibitData) {
            alert('Could not load exhibit data. Please try again.');
            return;
          }

          // Find recipe by name
          const recipe = exhibitData.items.find(item => item.name === recipeName);

          if (!recipe) {
            console.error('Could not find recipe:', recipeName);
            alert('Could not find recipe. Please try again.');
            return;
          }

          const recipeId = recipe.id;

          // Get reviews from embedded exhibit data (already loaded)
          const reviews = getReviewsFromExhibit(recipeId);

            let titleText = `Reviews for: ${recipeName}`;
            if (selectedFacets.all.length > 0) {
              titleText += ` (filtering for: ${selectedFacets.all.join(', ')})`;
            }
            document.getElementById('modalTitle').textContent = titleText;

            let html = '';
            if (reviews.length === 0) {
              html = '<p>No reviews with extracted attributes found for this recipe.</p>';
            } else {
              // Process reviews and calculate match counts
              const processedReviews = reviews.map(review => {
                const result = highlightSpans(review, selectedFacets.all);
                return {
                  html: result.html,
                  matchCount: result.matchCount,
                  review: review
                };
              });

              // Debug: Log review attributes to see what we're matching against
              console.log('Total reviews:', processedReviews.length);
              console.log('Selected facets:', selectedFacets.all);

              if (selectedFacets.all.length > 0 && reviews.length > 0) {
                console.log('Sample review attributes:', reviews[0].attributes?.map(a => a.entity).slice(0, 10));
              }

              // Filter reviews if facets are selected (only show reviews with matches)
              let filteredReviews = processedReviews;

              if (selectedFacets.all.length > 0) {
                filteredReviews = processedReviews.filter(item => item.matchCount > 0);
                console.log('Filtered reviews (with matches):', filteredReviews.length);

                if (filteredReviews.length === 0) {
                  console.warn('No matching reviews found! This might indicate a mismatch between facet values and review entities.');
                }
              }

              // Sort by match count (most matches first)
              filteredReviews.sort((a, b) => b.matchCount - a.matchCount);

              if (filteredReviews.length === 0) {
                html = '<p>No reviews found matching the selected attributes.</p>';
              } else {
                // Show reviews
                filteredReviews.forEach(item => {
                  const matchBadge = item.matchCount > 0
                    ? `<span style="background: #4a90e2; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-bottom: 8px; display: inline-block;">${item.matchCount} match${item.matchCount > 1 ? 'es' : ''}</span>`
                    : '';
                  html += `<div class="review-item" style="${item.matchCount > 0 ? 'border-left-width: 5px;' : ''}">`;
                  if (matchBadge) html += matchBadge;
                  html += `<div class="review-text">${item.html}</div>`;
                  html += `</div>`;
                });
              }
            }

            document.getElementById('modalReviews').innerHTML = html;
            document.getElementById('reviewModal').style.display = 'block';
        });
      }

      // Highlight spans in review text
      function highlightSpans(review, selectedAttributes = []) {
        const text = review.review_text || '';
        const attributes = review.attributes || [];

        // Debug: Log reviews with no attributes
        if (!attributes || attributes.length === 0) {
          console.log('Review with NO attributes:', text.substring(0, 100) + '...');
        }

        // Simply normalize selected attributes for matching (lowercase, trim)
        // Matching will be done against normalized_entity field in data
        const normalizedSelected = selectedAttributes.map(a => a.toLowerCase().trim());

        // Filter spans based on selected attributes (if any)
        const spans = [];
        let matchCount = 0;
        let invalidSpans = 0;

        attributes.forEach(attr => {
          // Check if span exists and has valid start/end properties
          if (!attr.span || attr.span.start === undefined || attr.span.end === undefined) {
            console.warn('Attribute missing span data:', attr.entity, 'dimension:', attr.dimension);
            invalidSpans++;
            return; // Skip attributes without valid spans
          }

          // Validate span indices
          const start = attr.span.start;
          const end = attr.span.end;

          if (start < 0 || end > text.length || start >= end) {
            console.warn('Invalid span:', attr.entity, 'start:', start, 'end:', end, 'text length:', text.length);
            invalidSpans++;
            return; // Skip invalid spans
          }

          // Match against normalized_entity (which is pre-computed in data)
          // This allows facet "husband" to match review entity "hubby"
          // while preserving original span text
          const normalizedEntity = (attr.normalized_entity || attr.entity || '').toLowerCase().trim();

          // If no filters, show all. Otherwise, check if normalized_entity matches
          const shouldShow = selectedAttributes.length === 0 ||
                           normalizedSelected.includes(normalizedEntity);

          if (shouldShow) {
            const spanText = text.substring(start, end);

            // Debug: check if span is empty or just whitespace
            if (!spanText.trim()) {
              console.warn('Empty span text for:', attr.entity, 'at', start, '-', end);
              invalidSpans++;
              return;
            }

            spans.push({
              start: start,
              end: end,
              dimension: attr.dimension,
              entity: attr.entity
            });

            // Count matches for selected attributes
            if (selectedAttributes.length > 0 && normalizedSelected.includes(normalizedEntity)) {
              matchCount++;
            }
          }
        });

        // Log summary if there were issues
        if (attributes.length > 0 && spans.length === 0) {
          console.log('Review has', attributes.length, 'attributes but 0 valid spans (', invalidSpans, 'invalid/missing)');
        }

        spans.sort((a, b) => a.start - b.start);

        let result = '';
        let lastEnd = 0;

        spans.forEach(span => {
          if (span.start >= lastEnd) {
            result += escapeHtml(text.substring(lastEnd, span.start));
            const dimClass = span.dimension.replace(/_/g, '');
            result += `<span class="highlight hl-${dimClass}" title="${span.dimension}: ${span.entity}">`;
            result += escapeHtml(text.substring(span.start, span.end));
            result += `</span>`;
            lastEnd = span.end;
          }
        });

        result += escapeHtml(text.substring(lastEnd));

        return {
          html: result,
          matchCount: matchCount
        };
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Close modal
      function closeModal() {
        document.getElementById('reviewModal').style.display = 'none';
      }

      // Click outside modal to close
      window.onclick = function(event) {
        const modal = document.getElementById('reviewModal');
        if (event.target == modal) {
          closeModal();
        }
      }

      // Smart search functionality
      function performSmartSearch() {
        const searchBox = document.getElementById('customSearchBox');
        if (!searchBox) return;

        const query = searchBox.value.trim();

        if (!query) {
          // Clear search if empty
          clearSearch();
          return;
        }

        // Stop words to filter out
        const stopWords = new Set([
          'for', 'my', 'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'of',
          'with', 'from', 'by', 'about', 'as', 'into', 'through', 'during', 'before',
          'after', 'above', 'below', 'between', 'under', 'again', 'further', 'then',
          'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'both', 'each',
          'few', 'more', 'most', 'other', 'some', 'such', 'only', 'own', 'same', 'so',
          'than', 'too', 'very', 'can', 'will', 'just', 'should', 'now', 'i', 'me',
          'food', 'foods', 'dish', 'dishes', 'recipe', 'recipes', 'meal', 'meals'
        ]);

        // Parse query into words
        const words = query.toLowerCase().split(/\s+/);

        // Filter out stop words and keep meaningful terms
        const searchTerms = words.filter(word => {
          return word.length > 2 && !stopWords.has(word);
        });

        // Capitalize first letter of each term (to match data format)
        // Data has mixed cases: "Christmas" (capitalized), "father" (lowercase)
        // So we'll try both: original and capitalized
        const capitalizedTerms = searchTerms.map(term => {
          // Common holidays/occasions that should be capitalized
          const capitalizeWords = ['christmas', 'thanksgiving', 'easter', 'halloween', 'valentine', 'birthday'];
          if (capitalizeWords.includes(term)) {
            return term.charAt(0).toUpperCase() + term.slice(1);
          }
          return term;
        });

        // If no meaningful terms, use original query
        const finalQuery = capitalizedTerms.length > 0 ? capitalizedTerms.join(' ') : query;

        // Update search status display
        const statusDiv = document.getElementById('searchStatus');
        const termsDisplay = document.getElementById('searchTermsDisplay');
        if (statusDiv && termsDisplay) {
          const displayText = searchTerms.join(', ') !== finalQuery
            ? `${finalQuery} (filtered from: "${query}")`
            : finalQuery;
          termsDisplay.textContent = displayText;
          statusDiv.classList.add('active');
        }

        // Custom search implementation: programmatically select facet values
        try {
          // First, clear any existing selections
          clearAllFacetSelections();

          // Then, select matching facet values for each search term
          const terms = capitalizedTerms;
          terms.forEach(term => {
            selectFacetValuesByTerm(term);
          });

        } catch (e) {
          console.error('Custom search failed:', e);
        }
      }

      // Clear all facet selections
      function clearAllFacetSelections() {
        const facetValueSelectors = document.querySelectorAll('.exhibit-facet-value');
        facetValueSelectors.forEach(elem => {
          if (elem.classList.contains('exhibit-facet-value-selected')) {
            elem.click(); // Deselect by clicking
          }
        });
      }

      // Select facet values that match the search term
      function selectFacetValuesByTerm(term) {
        const termLower = term.toLowerCase();
        const facetValueSelectors = document.querySelectorAll('.exhibit-facet-value');

        facetValueSelectors.forEach(elem => {
          const valueLower = elem.textContent.trim().toLowerCase();
          // Check if the facet value contains the search term
          if (valueLower.includes(termLower)) {
            if (!elem.classList.contains('exhibit-facet-value-selected')) {
              elem.click(); // Select by clicking
            }
          }
        });
      }

      function clearSearch() {
        const searchBox = document.getElementById('customSearchBox');
        if (searchBox) {
          searchBox.value = '';
        }

        // Hide search status
        const statusDiv = document.getElementById('searchStatus');
        if (statusDiv) {
          statusDiv.classList.remove('active');
        }

        // Clear all facet selections by clicking the "Reset All Filters" link
        const resetLink = document.querySelector('a[href*="clearRestrictions"]');
        if (resetLink) {
          resetLink.click();
        } else {
          // Fallback: manually deselect all facets
          clearAllFacetSelections();
        }
      }

      // Support Enter key for search
      // Wait for Exhibit to fully initialize
      function initializeCustomSearch() {
        const searchBox = document.getElementById('customSearchBox');
        if (searchBox) {
          searchBox.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              performSmartSearch();
            }
          });

          // Add clear button on Escape
          searchBox.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
              clearSearch();
            }
          });
        }
      }

      // Open recipe modal
      function openRecipeModal(thumbElement) {
        const modal = document.getElementById('recipeModal');
        const modalBody = document.getElementById('recipeModalBody');

        // Extract recipe data from thumbnail
        const dataSpans = thumbElement.querySelectorAll('.recipe-data');
        const recipeData = {};
        dataSpans.forEach(span => {
          const field = span.getAttribute('data-field');
          recipeData[field] = span.textContent.trim();
        });

        // Build modal content
        const html = `
          <div class="recipe-card">
            <div class="recipe-header">
              <div class="recipe-image-wrapper">
                <img src="${recipeData.image}" alt="${recipeData.name}" />
              </div>
              <div class="recipe-header-info">
                <h2 class="recipe-title">${recipeData.name}</h2>
                <div class="recipe-meta">
                  <span class="recipe-meta-item">Rating: ${recipeData.rating}</span>
                  <span class="recipe-meta-item">${recipeData.reviews} reviews</span>
                  <span class="recipe-meta-item">${recipeData.calories} cal</span>
                </div>
              </div>
            </div>

            <div class="recipe-content">
              <div class="recipe-columns">
                <div class="recipe-column">
                  <div class="recipe-section">
                    <h4>Ingredients</h4>
                    <ul class="ingredients-list">${formatList(recipeData.ingredients, 'li')}</ul>
                  </div>
                </div>

                <div class="recipe-column">
                  <div class="recipe-section">
                    <h4>Instructions</h4>
                    <ol class="instructions-list">${formatList(recipeData.instructions, 'li')}</ol>
                  </div>
                </div>
              </div>

              <div class="recipe-footer">
                <div class="recipe-tags">
                  <strong>Subjective Attributes:</strong> ${formatAttributes(recipeData.attributes, recipeData.name)}
                </div>
                <button class="view-reviews-btn" onclick="showReviewsFromModal('${recipeData.name.replace(/'/g, "\\'")}')">
                  View Reviews with Highlights
                </button>
              </div>
            </div>
          </div>
        `;

        modalBody.innerHTML = html;
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }

      // Close recipe modal
      function closeRecipeModal() {
        const modal = document.getElementById('recipeModal');
        modal.style.display = 'none';
        document.body.style.overflow = '';
      }

      // Format comma-separated list into HTML list items
      function formatList(text, tag) {
        const items = text.split(',').map(s => s.trim()).filter(s => s);
        return items.map(item => `<${tag}>${item}</${tag}>`).join('');
      }

      // Format attributes with vegetarian alternative labeling
      function formatAttributes(text, recipeName) {
        const hasMeat = /chicken|beef|pork|lamb|turkey|bacon|sausage|ham|steak|meat/i.test(recipeName);
        if (hasMeat && /vegetarian/i.test(text)) {
          return text.replace(/(vegetarian)/gi, '$1 <span style="color: #999; font-size: 0.85em;">(alternative)</span>');
        }
        return text;
      }

      // Show reviews from modal
      function showReviewsFromModal(recipeName) {
        // Get selected facets
        const selectedFacets = getSelectedFacets();

        // Load exhibit data to find recipe
        loadExhibitData().then(exhibitData => {
          if (!exhibitData) {
            alert('Could not load exhibit data. Please try again.');
            return;
          }

          // Find recipe by name
          const recipe = exhibitData.items.find(item => item.name === recipeName);

          if (!recipe) {
            console.error('Could not find recipe:', recipeName);
            alert('Could not find recipe. Please try again.');
            return;
          }

          const recipeId = recipe.id;

          // Get reviews from embedded exhibit data
          const reviews = getReviewsFromExhibit(recipeId);

          let titleText = `Reviews for: ${recipeName}`;
          if (selectedFacets.all.length > 0) {
            titleText += ` (filtering for: ${selectedFacets.all.join(', ')})`;
          }
          document.getElementById('modalTitle').textContent = titleText;

          let html = '';
          if (reviews.length === 0) {
            html = '<p>No reviews with extracted attributes found for this recipe.</p>';
          } else {
            // Process reviews and calculate match counts using highlightSpans
            const processedReviews = reviews.map(review => {
              const result = highlightSpans(review, selectedFacets.all);
              return {
                html: result.html,
                matchCount: result.matchCount,
                review: review
              };
            });

            // Filter reviews if facets are selected
            let filteredReviews = processedReviews;
            if (selectedFacets.all.length > 0) {
              filteredReviews = processedReviews.filter(item => item.matchCount > 0);
            }

            // Sort by match count
            filteredReviews.sort((a, b) => b.matchCount - a.matchCount);

            if (filteredReviews.length === 0 && selectedFacets.all.length > 0) {
              html = '<p>No reviews found matching the selected attributes.</p>';
            } else {
              // Show reviews
              filteredReviews.forEach(item => {
                const matchBadge = item.matchCount > 0
                  ? `<span style="background: #4a90e2; color: white; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; margin-bottom: 8px; display: inline-block;">${item.matchCount} match${item.matchCount > 1 ? 'es' : ''}</span>`
                  : '';
                html += `<div class="review-item" style="${item.matchCount > 0 ? 'border-left-width: 5px;' : ''}">`;
                if (matchBadge) html += matchBadge;
                html += `<div class="review-text">${item.html}</div>`;
                html += `</div>`;
              });
            }
          }

          document.getElementById('modalReviews').innerHTML = html;
          document.getElementById('reviewModal').style.display = 'block';

          // Close recipe modal
          closeRecipeModal();
        });
      }

      // Close modal on ESC key
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeRecipeModal();
        }
      });

      // Close modal on background click
      document.addEventListener('click', function(e) {
        const modal = document.getElementById('recipeModal');
        if (e.target === modal) {
          closeRecipeModal();
        }
      });

      // Format arrays as proper HTML lists
      function formatRecipeLists() {
        document.querySelectorAll('.ingredients-list').forEach(ul => {
          const content = ul.textContent.trim();
          if (content && !ul.querySelector('li:not([data-ex-content])') && !ul.hasAttribute('data-formatted')) {
            ul.innerHTML = '';
            const items = content.split(',').map(s => s.trim()).filter(s => s);
            if (items.length > 0) {
              items.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item;
                ul.appendChild(li);
              });
              ul.setAttribute('data-formatted', 'true');
            }
          }
        });

        document.querySelectorAll('.instructions-list').forEach(ol => {
          const content = ol.textContent.trim();
          if (content && !ol.querySelector('li:not([data-ex-content])') && !ol.hasAttribute('data-formatted')) {
            ol.innerHTML = '';
            const items = content.split(',').map(s => s.trim()).filter(s => s);
            if (items.length > 0) {
              items.forEach(item => {
                const li = document.createElement('li');
                li.textContent = item;
                ol.appendChild(li);
              });
              ol.setAttribute('data-formatted', 'true');
            }
          }
        });

        // Add "(alternative)" label to vegetarian attributes for meat-based recipes
        document.querySelectorAll('.recipe-card').forEach(card => {
          const title = card.querySelector('.recipe-title');
          const tagsDiv = card.querySelector('.recipe-tags span');

          if (title && tagsDiv && !card.hasAttribute('data-veg-checked')) {
            const recipeName = title.textContent.toLowerCase();
            const hasMeat = /chicken|beef|pork|lamb|turkey|bacon|sausage|ham|steak|meat/.test(recipeName);

            if (hasMeat) {
              const tags = tagsDiv.textContent;
              if (tags.includes('vegetarian') && !tags.includes('(alternative)')) {
                tagsDiv.innerHTML = tags.replace(/(vegetarian)/gi, '$1 <span style="color: #999; font-size: 0.85em;">(alternative)</span>');
              }
            }
            card.setAttribute('data-veg-checked', 'true');
          }
        });
      }


      // Attach click handlers to thumbnails
      function attachThumbnailHandlers() {
        const thumbnails = document.querySelectorAll('.recipe-thumb');
        thumbnails.forEach(thumb => {
          // Remove any existing handlers
          const newThumb = thumb.cloneNode(true);
          thumb.parentNode.replaceChild(newThumb, thumb);

          // Add click handler to entire thumbnail
          newThumb.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            openRecipeModal(this);
            return false;
          }, true);
        });
      }

      // Initialize after DOM is ready
      document.addEventListener('DOMContentLoaded', function() {
        // Wait for Exhibit to initialize
        setTimeout(initializeCustomSearch, 1000);

        // Attach thumbnail handlers after Exhibit renders
        setTimeout(attachThumbnailHandlers, 2000);

        // Re-attach handlers when pagination changes
        setInterval(attachThumbnailHandlers, 1000);
      });
    </script>
  </body>
</html>
